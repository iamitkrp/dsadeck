import type { Question, QuestionsIndex } from "./questions-types";

// Small curated dataset: 10 per difficulty
// Starters are minimal; solutions are primarily for JS to keep the repo light

function jsStarter(name: string) {
  return `// ${name}\n// Implement and return the result from solve().\nexport function solve(input) {\n  // TODO\n  return null;\n}`;
}
function pyStarter(name: string) {
  return `# ${name}\n# Implement and return the result from solve().\ndef solve(input):\n    # TODO\n    return None\n`;
}
function cppStarter(name: string) {
  return `// ${name}\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){ return 0; }\n`;
}

// EASY (10)
const EASY: Question[] = [
  {
    id: "easy-001",
    slug: "easy-two-sum",
    title: "Two Sum",
    difficulty: "easy",
    tags: ["arrays", "hashing"],
    statement:
      "Given an integer array nums and a target, return the indices of two numbers such that they add up to target.\nReturn the first pair you find; exactly one valid pair exists. Each element can be used at most once.",
    examples: [
      { input: "nums = [2,7,11,15], target = 9", output: "[0,1]", explanation: "nums[0] + nums[1] = 2 + 7 = 9" },
      { input: "nums = [3,2,4], target = 6", output: "[1,2]" },
    ],
    constraints: [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i], target <= 10^9",
      "Exactly one valid answer exists",
    ],
    starterCode: { javascript: jsStarter("Two Sum"), python: pyStarter("Two Sum"), cpp: cppStarter("Two Sum") },
    hints: ["Brute force pairs is O(n^2).", "Use a map value->index and check complement in O(1)."],
    solution: {
      javascript: `export function solve({ nums, target }) {\n  const m = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const need = target - nums[i];\n    if (m.has(need)) return [m.get(need), i];\n    m.set(nums[i], i);\n  }\n  return [];\n}`,
    },
  },
  {
    id: "easy-002",
    slug: "easy-sorted-squared-array",
    title: "Sorted Squared Array",
    difficulty: "easy",
    tags: ["arrays", "two-pointers"],
    statement: "Given a non-decreasing integer array, return a new array containing the squares of each number, also sorted non-decreasing.",
    examples: [
      { input: "[-4,-1,0,3,10]", output: "[0,1,9,16,100]" },
      { input: "[-7,-3,2,3,11]", output: "[4,9,9,49,121]" },
    ],
    constraints: ["1 <= n <= 10^5", "-10^4 <= nums[i] <= 10^4", "Array is non-decreasing"],
    starterCode: { javascript: jsStarter("Sorted Squared Array"), python: pyStarter("Sorted Squared Array"), cpp: cppStarter("Sorted Squared Array") },
    hints: ["Squares of negatives may be largest.", "Use two pointers and fill from the end."],
    solution: { javascript: `export function solve(nums){ const n=nums.length,res=Array(n); let l=0,r=n-1,i=n-1; while(l<=r){ const a=nums[l]*nums[l], b=nums[r]*nums[r]; if(a>b){ res[i--]=a; l++; } else { res[i--]=b; r--; } } return res; }` },
  },
  {
    id: "easy-003",
    slug: "easy-validate-subsequence",
    title: "Validate Subsequence",
    difficulty: "easy",
    tags: ["arrays", "two-pointers"],
    statement: "Given an array and a sequence, return true if the sequence is a subsequence of the array (appears in the same order but not necessarily contiguously).",
    examples: [
      { input: "array = [5,1,22,25,6,-1,8,10], sequence = [1,6,-1,10]", output: "true" },
      { input: "array = [1,2,3,4], sequence = [2,4,6]", output: "false" },
    ],
    constraints: ["1 <= array.length <= 10^5", "sequence.length <= array.length"],
    starterCode: { javascript: jsStarter("Validate Subsequence"), python: pyStarter("Validate Subsequence"), cpp: cppStarter("Validate Subsequence") },
    hints: ["Walk array once, advance seq index on match."],
    solution: { javascript: `export function solve({ array, sequence }){ let i=0; for(const v of array){ if(i<sequence.length && v===sequence[i]) i++; } return i===sequence.length; }` },
  },
  {
    id: "easy-004",
    slug: "easy-is-palindrome",
    title: "Is Palindrome",
    difficulty: "easy",
    tags: ["strings", "two-pointers"],
    statement: "Return true if a string reads the same forward and backward.",
    examples: [
      { input: "s = 'racecar'", output: "true" },
      { input: "s = 'hello'", output: "false" },
    ],
    constraints: ["1 <= s.length <= 10^5"],
    starterCode: { javascript: jsStarter("Is Palindrome"), python: pyStarter("Is Palindrome"), cpp: cppStarter("Is Palindrome") },
    hints: ["Compare characters from both ends."],
    solution: { javascript: `export function solve(s){ let l=0,r=s.length-1; while(l<r){ if(s[l++]!==s[r--]) return false; } return true; }` },
  },
  {
    id: "easy-005",
    slug: "easy-non-constructible-change",
    title: "Non-Constructible Change",
    difficulty: "easy",
    tags: ["greedy", "arrays"],
    statement: "Given coin values, return the minimum amount of change that cannot be created with any subset of coins.",
    examples: [
      { input: "[1,1,2,3,5,7,22]", output: "20" },
      { input: "[1,2,5]", output: "4" },
    ],
    constraints: ["1 <= coins.length <= 10^5", "1 <= coins[i] <= 10^6"],
    starterCode: { javascript: jsStarter("Non-Constructible Change"), python: pyStarter("Non-Constructible Change"), cpp: cppStarter("Non-Constructible Change") },
    hints: ["Sort, track current constructible range [1..cur]."],
    solution: { javascript: `export function solve(coins){ coins.sort((a,b)=>a-b); let cur=0; for(const c of coins){ if(c>cur+1) return cur+1; cur+=c; } return cur+1; }` },
  },
  {
    id: "easy-006",
    slug: "easy-tournament-winner",
    title: "Tournament Winner",
    difficulty: "easy",
    tags: ["hashing"],
    statement: "Given matchups and results (1 = home team won), compute the team with the highest points (3 points per win).",
    examples: [
      { input: "competitions = [[\"HTML\",\"C#\"],[\"C#\",\"Python\"],[\"Python\",\"HTML\"]], results = [0,0,1]", output: "\"Python\"" },
    ],
    constraints: ["1 <= competitions.length <= 10^5"],
    starterCode: { javascript: jsStarter("Tournament Winner"), python: pyStarter("Tournament Winner"), cpp: cppStarter("Tournament Winner") },
    hints: ["Map team -> points; maintain current best."],
    solution: { javascript: `export function solve({competitions, results}){ const pts=new Map(); let best='',score=0; for(let i=0;i<competitions.length;i++){ const [h,a]=competitions[i]; const w=results[i]===1?h:a; pts.set(w,(pts.get(w)||0)+3); if((pts.get(w)||0)>score){ best=w; score=pts.get(w)||0; } } return best; }` },
  },
  {
    id: "easy-007",
    slug: "easy-product-sum",
    title: "Product Sum (Nested Arrays)",
    difficulty: "easy",
    tags: ["recursion", "arrays"],
    statement: "Given a 'special' array (nested arrays), return its product sum: sum of elements, where nested arrays are summed and multiplied by their depth.",
    examples: [
      { input: "[5,2,[7,-1],3,[6,[-13,8],4]]", output: "12" },
    ],
    constraints: ["Total number of integers across nesting <= 10^5"],
    starterCode: { javascript: jsStarter("Product Sum"), python: pyStarter("Product Sum"), cpp: cppStarter("Product Sum") },
    hints: ["Use recursion with depth parameter."],
    solution: { javascript: `export function solve(arr, depth=1){ let sum=0; for(const v of arr){ sum += Array.isArray(v)? solve(v, depth+1): v; } return sum*depth; }` },
  },
  {
    id: "easy-008",
    slug: "easy-find-closest-value-in-bst",
    title: "Find Closest Value in BST",
    difficulty: "easy",
    tags: ["bst", "trees"],
    statement: "Given a BST and a target integer, return the value in the BST that is closest to the target.",
    examples: [
      { input: "BST = {10, 5, 15, 2, 5, 13, 22, 1, null, 14}, target = 12", output: "13" },
    ],
    constraints: ["BST contains 1..10^5 nodes"],
    starterCode: { javascript: jsStarter("Find Closest Value in BST"), python: pyStarter("Find Closest Value in BST"), cpp: cppStarter("Find Closest Value in BST") },
    hints: ["Walk the BST using target to decide direction; track best."],
    solution: { javascript: `export function solve({root,target}){ let cur=root, best=Infinity, ans=null; while(cur){ const d=Math.abs(cur.value-target); if(d<best){ best=d; ans=cur.value; } cur = target<cur.value ? cur.left : cur.right; } return ans; }` },
  },
  {
    id: "easy-009",
    slug: "easy-remove-duplicates-sorted-array",
    title: "Remove Duplicates from Sorted Array (Length)",
    difficulty: "easy",
    tags: ["arrays", "two-pointers"],
    statement: "Given a sorted array, remove duplicates in-place and return the new length.",
    examples: [
      { input: "[1,1,2]", output: "2 (array becomes [1,2,_])" },
    ],
    constraints: ["1 <= nums.length <= 10^5"],
    starterCode: { javascript: jsStarter("Remove Duplicates from Sorted Array"), python: pyStarter("Remove Duplicates from Sorted Array"), cpp: cppStarter("Remove Duplicates from Sorted Array") },
    hints: ["Use a slow pointer to write unique elements."],
    solution: { javascript: `export function solve(nums){ if(nums.length===0) return 0; let k=1; for(let i=1;i<nums.length;i++) if(nums[i]!==nums[i-1]) nums[k++]=nums[i]; return k; }` },
  },
  {
    id: "easy-010",
    slug: "easy-binary-search",
    title: "Binary Search",
    difficulty: "easy",
    tags: ["binary-search"],
    statement: "Given a sorted array and a target, return the index of the target or -1 if not present.",
    examples: [
      { input: "nums = [-1,0,3,5,9,12], target = 9", output: "4" },
    ],
    constraints: ["1 <= nums.length <= 10^5", "nums is sorted ascending"],
    starterCode: { javascript: jsStarter("Binary Search"), python: pyStarter("Binary Search"), cpp: cppStarter("Binary Search") },
    hints: ["Maintain inclusive [l,r] bounds; compare with mid."],
    solution: { javascript: `export function solve({nums, target}){ let l=0,r=nums.length-1; while(l<=r){ const m=(l+r)>>1; if(nums[m]===target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return -1; }` },
  },
];

// INTERMEDIATE (10)
const INTERMEDIATE: Question[] = [
  {
    id: "intermediate-001",
    slug: "intermediate-three-sum",
    title: "Three Sum",
    difficulty: "intermediate",
    tags: ["arrays", "two-pointers", "sorting"],
    statement: "Given an integer array nums, return all unique triplets [a,b,c] such that a + b + c = 0.",
    examples: [
      { input: "[-1,0,1,2,-1,-4]", output: "[[-1,-1,2],[-1,0,1]]" },
    ],
    starterCode: { javascript: jsStarter("Three Sum"), python: pyStarter("Three Sum"), cpp: cppStarter("Three Sum") },
    hints: ["Sort and sweep with two pointers.", "Skip duplicates carefully."],
    solution: { javascript: `export function solve(nums){ nums.sort((a,b)=>a-b); const res=[]; for(let i=0;i<nums.length;i++){ if(i&&nums[i]===nums[i-1]) continue; let l=i+1,r=nums.length-1; while(l<r){ const s=nums[i]+nums[l]+nums[r]; if(s===0){ res.push([nums[i],nums[l],nums[r]]); while(l<r&&nums[l]===nums[l+1]) l++; while(l<r&&nums[r]===nums[r-1]) r--; l++; r--; } else if(s<0) l++; else r--; } } return res; }` },
  },
  {
    id: "intermediate-002",
    slug: "intermediate-group-anagrams",
    title: "Group Anagrams",
    difficulty: "intermediate",
    tags: ["hashing", "strings"],
    statement: "Group a list of strings into anagrams.",
    examples: [
      { input: "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]", output: "[[eat,tea,ate],[tan,nat],[bat]] (order may vary)" },
    ],
    starterCode: { javascript: jsStarter("Group Anagrams"), python: pyStarter("Group Anagrams"), cpp: cppStarter("Group Anagrams") },
    hints: ["Key by sorted word or char counts."],
    solution: { javascript: `export function solve(strs){ const m=new Map(); for(const s of strs){ const k=[...s].sort().join(''); if(!m.has(k)) m.set(k,[]); m.get(k).push(s); } return [...m.values()]; }` },
  },
  {
    id: "intermediate-003",
    slug: "intermediate-merge-intervals",
    title: "Merge Overlapping Intervals",
    difficulty: "intermediate",
    tags: ["intervals", "sorting"],
    statement: "Given a list of intervals [start,end], merge all overlapping intervals.",
    examples: [
      { input: "[[1,3],[2,6],[8,10],[15,18]]", output: "[[1,6],[8,10],[15,18]]" },
    ],
    starterCode: { javascript: jsStarter("Merge Overlapping Intervals"), python: pyStarter("Merge Overlapping Intervals"), cpp: cppStarter("Merge Overlapping Intervals") },
    hints: ["Sort by start; extend or push new window."],
    solution: { javascript: `export function solve(intervals){ if(!intervals.length) return []; intervals.sort((a,b)=>a[0]-b[0]); const res=[intervals[0].slice()]; for(const [s,e] of intervals.slice(1)){ const last=res[res.length-1]; if(s<=last[1]) last[1]=Math.max(last[1],e); else res.push([s,e]); } return res; }` },
  },
  {
    id: "intermediate-004",
    slug: "intermediate-kadane-max-subarray",
    title: "Maximum Subarray Sum (Kadane)",
    difficulty: "intermediate",
    tags: ["dp", "arrays"],
    statement: "Return the maximum subarray sum.",
    examples: [
      { input: "[-2,1,-3,4,-1,2,1,-5,4]", output: "6 (subarray [4,-1,2,1])" },
    ],
    starterCode: { javascript: jsStarter("Kadane"), python: pyStarter("Kadane"), cpp: cppStarter("Kadane") },
    hints: ["Track running best and global best."],
    solution: { javascript: `export function solve(nums){ let cur=nums[0], best=nums[0]; for(let i=1;i<nums.length;i++){ cur=Math.max(nums[i],cur+nums[i]); best=Math.max(best,cur);} return best; }` },
  },
  {
    id: "intermediate-005",
    slug: "intermediate-linked-list-cycle",
    title: "Linked List Cycle",
    difficulty: "intermediate",
    tags: ["linked-list", "two-pointers"],
    statement: "Detect if a linked list has a cycle.",
    examples: [
      { input: "head = [3,2,0,-4], pos = 1", output: "true" },
    ],
    starterCode: { javascript: jsStarter("Linked List Cycle"), python: pyStarter("Linked List Cycle"), cpp: cppStarter("Linked List Cycle") },
    hints: ["Floyd's slow/fast pointers."],
    solution: { javascript: `export function solve(head){ let s=head,f=head; while(f&&f.next){ s=s.next; f=f.next.next; if(s===f) return true; } return false; }` },
  },
  {
    id: "intermediate-006",
    slug: "intermediate-longest-palindromic-substring",
    title: "Longest Palindromic Substring",
    difficulty: "intermediate",
    tags: ["strings", "two-pointers"],
    statement: "Return the longest palindromic substring of s.",
    examples: [
      { input: "babad", output: "bab (or aba)" },
    ],
    starterCode: { javascript: jsStarter("Longest Palindromic Substring"), python: pyStarter("Longest Palindromic Substring"), cpp: cppStarter("Longest Palindromic Substring") },
    hints: ["Expand around centers (odd and even)."],
    solution: { javascript: `export function solve(s){ let best=''; const exp=(l,r)=>{ while(l>=0&&r<s.length&&s[l]===s[r]){ l--; r++; } return s.slice(l+1,r); }; for(let i=0;i<s.length;i++){ const a=exp(i,i), b=exp(i,i+1); const c=a.length>b.length?a:b; if(c.length>best.length) best=c; } return best; }` },
  },
  {
    id: "intermediate-007",
    slug: "intermediate-valid-parentheses",
    title: "Valid Parentheses",
    difficulty: "intermediate",
    tags: ["stack"],
    statement: "Given a string containing just '()[]{}', determine if the string is valid.",
    examples: [
      { input: "()[]{}", output: "true" },
      { input: "(]", output: "false" },
    ],
    starterCode: { javascript: jsStarter("Valid Parentheses"), python: pyStarter("Valid Parentheses"), cpp: cppStarter("Valid Parentheses") },
    hints: ["Push opens; match closes with last open."],
    solution: { javascript: `export function solve(s){ const st=[], m={')':'(','}':'{',']':'['}; for(const ch of s){ if(m[ch]){ if(st.pop()!==m[ch]) return false; } else st.push(ch); } return st.length===0; }` },
  },
  {
    id: "intermediate-008",
    slug: "intermediate-rotate-array",
    title: "Rotate Array",
    difficulty: "intermediate",
    tags: ["arrays"],
    statement: "Rotate array to the right by k steps in-place.",
    examples: [
      { input: "nums = [1,2,3,4,5,6,7], k = 3", output: "[5,6,7,1,2,3,4]" },
    ],
    starterCode: { javascript: jsStarter("Rotate Array"), python: pyStarter("Rotate Array"), cpp: cppStarter("Rotate Array") },
    hints: ["Reverse whole, then parts."],
    solution: { javascript: `export function solve({nums,k}){ k%=nums.length; const rev=(l,r)=>{ while(l<r){ [nums[l],nums[r]]=[nums[r],nums[l]]; l++; r--; } }; rev(0,nums.length-1); rev(0,k-1); rev(k,nums.length-1); return nums; }` },
  },
  {
    id: "intermediate-009",
    slug: "intermediate-min-stack",
    title: "Min Stack",
    difficulty: "intermediate",
    tags: ["stack", "design"],
    statement: "Design a stack supporting push, pop, top, and getMin in O(1).",
    examples: [
      { input: "push(-2), push(0), push(-3), getMin(), pop(), top(), getMin()", output: "-3, null, 0, -2" },
    ],
    starterCode: { javascript: jsStarter("Min Stack"), python: pyStarter("Min Stack"), cpp: cppStarter("Min Stack") },
    hints: ["Maintain a parallel min stack."],
    solution: { javascript: `export function solve(){ class MinStack{ constructor(){this.s=[];this.m=[];} push(x){ this.s.push(x); this.m.push(this.m.length?Math.min(x,this.m[this.m.length-1]):x);} pop(){ this.s.pop(); this.m.pop(); } top(){ return this.s[this.s.length-1]; } getMin(){ return this.m[this.m.length-1]; } } return MinStack; }` },
  },
  {
    id: "intermediate-010",
    slug: "intermediate-course-schedule",
    title: "Course Schedule (Can Finish?)",
    difficulty: "intermediate",
    tags: ["graph", "topological-sort"],
    statement: "Given prerequisites, determine if all courses can be finished.",
    examples: [
      { input: "numCourses = 2, prerequisites = [[1,0]]", output: "true" },
      { input: "numCourses = 2, prerequisites = [[1,0],[0,1]]", output: "false" },
    ],
    starterCode: { javascript: jsStarter("Course Schedule"), python: pyStarter("Course Schedule"), cpp: cppStarter("Course Schedule") },
    hints: ["Detect cycle using Kahn's BFS (indegree)."],
    solution: { javascript: `export function solve({numCourses, prerequisites}){ const g=Array.from({length:numCourses},()=>[]); const indeg=Array(numCourses).fill(0); for(const [a,b] of prerequisites){ g[b].push(a); indeg[a]++; } const q=[]; for(let i=0;i<numCourses;i++) if(indeg[i]===0) q.push(i); let seen=0; while(q.length){ const u=q.shift(); seen++; for(const v of g[u]) if(--indeg[v]===0) q.push(v); } return seen===numCourses; }` },
  },
];

// HARD (10)
const HARD: Question[] = [
  {
    id: "hard-001",
    slug: "hard-word-ladder",
    title: "Word Ladder",
    difficulty: "hard",
    tags: ["graph", "bfs"],
    statement: "Length of shortest transformation from beginWord to endWord given a dictionary. At each step, change exactly one letter and each intermediate word must exist in the dictionary.",
    examples: [
      { input: "beginWord = hit, endWord = cog, wordList = [hot,dot,dog,lot,log,cog]", output: "5 (hit->hot->dot->dog->cog)" },
    ],
    starterCode: { javascript: jsStarter("Word Ladder"), python: pyStarter("Word Ladder"), cpp: cppStarter("Word Ladder") },
    hints: ["BFS over implicit graph via wildcard buckets."],
    solution: { javascript: `export function solve({beginWord,endWord,wordList}){ const dict=new Set(wordList); if(!dict.has(endWord)) return 0; const buckets=new Map(); const add=(w,i)=>{ const k=w.slice(0,i)+'*'+w.slice(i+1); if(!buckets.has(k)) buckets.set(k,[]); buckets.get(k).push(w); }; for(const w of dict){ for(let i=0;i<w.length;i++) add(w,i);} const q=[[beginWord,1]], seen=new Set([beginWord]); while(q.length){ const [w,d]=q.shift(); if(w===endWord) return d; for(let i=0;i<w.length;i++){ const k=w.slice(0,i)+'*'+w.slice(i+1); for(const nxt of buckets.get(k)||[]){ if(!seen.has(nxt)){ seen.add(nxt); q.push([nxt,d+1]); } } } } return 0; }` },
  },
  {
    id: "hard-002",
    slug: "hard-dijkstra",
    title: "Dijkstra's Shortest Path",
    difficulty: "hard",
    tags: ["graph", "dijkstra", "heap"],
    statement: "Compute shortest distances from a source in a weighted graph with non‑negative edges.",
    starterCode: { javascript: jsStarter("Dijkstra"), python: pyStarter("Dijkstra"), cpp: cppStarter("Dijkstra") },
    hints: ["Use a min-heap; relax edges on improvement."],
    solution: { javascript: `export function solve({n, edges, src}){ const g=Array.from({length:n},()=>[]); for(const [u,v,w] of edges){ g[u].push([v,w]); g[v].push([u,w]); } const dist=Array(n).fill(Infinity); dist[src]=0; const pq=[[0,src]]; while(pq.length){ pq.sort((a,b)=>a[0]-b[0]); const [d,u]=pq.shift(); if(d!==dist[u]) continue; for(const [v,w] of g[u]){ if(d+w<dist[v]){ dist[v]=d+w; pq.push([dist[v],v]); } } } return dist; }` },
  },
  {
    id: "hard-003",
    slug: "hard-edit-distance",
    title: "Edit Distance",
    difficulty: "hard",
    tags: ["dp", "strings"],
    statement: "Return the minimum number of operations to convert word1 to word2 (insert, delete, replace).",
    examples: [
      { input: "horse -> ros", output: "3" },
    ],
    starterCode: { javascript: jsStarter("Edit Distance"), python: pyStarter("Edit Distance"), cpp: cppStarter("Edit Distance") },
    hints: ["DP over prefixes; transitions for insert/delete/replace."],
    solution: { javascript: `export function solve({a,b}){ const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0)); for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j; for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ if(a[i-1]===b[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]); } } return dp[m][n]; }` },
  },
  {
    id: "hard-004",
    slug: "hard-trapping-rain-water",
    title: "Trapping Rain Water",
    difficulty: "hard",
    tags: ["two-pointers", "arrays"],
    statement: "Given non‑negative integers representing elevation map, compute how much water it can trap after raining.",
    examples: [
      { input: "[0,1,0,2,1,0,1,3,2,1,2,1]", output: "6" },
    ],
    starterCode: { javascript: jsStarter("Trapping Rain Water"), python: pyStarter("Trapping Rain Water"), cpp: cppStarter("Trapping Rain Water") },
    hints: ["Two pointers with leftMax/rightMax."],
    solution: { javascript: `export function solve(h){ let l=0,r=h.length-1,lm=0,rm=0,ans=0; while(l<r){ if(h[l]<h[r]){ lm=Math.max(lm,h[l]); ans+=lm-h[l++]; } else { rm=Math.max(rm,h[r]); ans+=rm-h[r--]; } } return ans; }` },
  },
  {
    id: "hard-005",
    slug: "hard-lis",
    title: "Longest Increasing Subsequence (O(n log n))",
    difficulty: "hard",
    tags: ["dp", "binary-search"],
    statement: "Return the length of LIS.",
    starterCode: { javascript: jsStarter("LIS"), python: pyStarter("LIS"), cpp: cppStarter("LIS") },
    hints: ["Patience sorting (tails) + binary search."],
    solution: { javascript: `export function solve(nums){ const tails=[]; for(const x of nums){ let l=0,r=tails.length; while(l<r){ const m=(l+r)>>1; if(tails[m]<x) l=m+1; else r=m; } tails[l]=x; } return tails.length; }` },
  },
  {
    id: "hard-006",
    slug: "hard-median-of-two-sorted-arrays",
    title: "Median of Two Sorted Arrays",
    difficulty: "hard",
    tags: ["binary-search"],
    statement: "Find the median of two sorted arrays in O(log(min(m,n))).",
    starterCode: { javascript: jsStarter("Median of Two Sorted Arrays"), python: pyStarter("Median of Two Sorted Arrays"), cpp: cppStarter("Median of Two Sorted Arrays") },
    hints: ["Binary search partition on smaller array."],
    solution: { javascript: `export function solve({A,B}){ if(A.length>B.length) [A,B]=[B,A]; let m=A.length,n=B.length,l=0,r=m; while(l<=r){ const i=(l+r)>>1, j=((m+n+1)>>1)-i; const Al=i?A[i-1]:-Infinity, Ar=i<m?A[i]:Infinity; const Bl=j?B[j-1]:-Infinity, Br=j<n?B[j]:Infinity; if(Al<=Br && Bl<=Ar){ return ((m+n)&1)===0 ? (Math.max(Al,Bl)+Math.min(Ar,Br))/2 : Math.max(Al,Bl); } if(Al>Br) r=i-1; else l=i+1; } }` },
  },
  {
    id: "hard-007",
    slug: "hard-lru-cache",
    title: "LRU Cache",
    difficulty: "hard",
    tags: ["design", "hashing", "linked-list"],
    statement: "Design LRU cache with O(1) get/put.",
    starterCode: { javascript: jsStarter("LRU Cache"), python: pyStarter("LRU Cache"), cpp: cppStarter("LRU Cache") },
    hints: ["Hash map + doubly linked list."],
    solution: { javascript: `export function solve(){ class Node{ constructor(k,v){this.k=k;this.v=v;this.p=this.n=null;} } class LRU{ constructor(cap){this.cap=cap; this.m=new Map(); this.h=new Node(0,0); this.t=new Node(0,0); this.h.n=this.t; this.t.p=this.h;} _add(n){ n.n=this.h.n; n.p=this.h; this.h.n.p=n; this.h.n=n;} _rm(n){ n.p.n=n.n; n.n.p=n.p;} get(k){ if(!this.m.has(k)) return -1; const n=this.m.get(k); this._rm(n); this._add(n); return n.v;} put(k,v){ if(this.m.has(k)){ const n=this.m.get(k); n.v=v; this._rm(n); this._add(n); return;} const n=new Node(k,v); this.m.set(k,n); this._add(n); if(this.m.size>this.cap){ const x=this.t.p; this._rm(x); this.m.delete(x.k); } } } return LRU; }` },
  },
  {
    id: "hard-008",
    slug: "hard-serialize-deserialize-bt",
    title: "Serialize and Deserialize Binary Tree",
    difficulty: "hard",
    tags: ["trees", "bfs"],
    statement: "Implement serialize(root) and deserialize(data) of a binary tree.",
    starterCode: { javascript: jsStarter("Serialize/Deserialize BT"), python: pyStarter("Serialize/Deserialize BT"), cpp: cppStarter("Serialize/Deserialize BT") },
    hints: ["Use BFS with null markers and join/split by delimiter."],
    solution: { javascript: `export function solve(){ const ser=(root)=>{ const q=[root], out=[]; while(q.length){ const n=q.shift(); if(!n){ out.push('#'); continue;} out.push(String(n.val)); q.push(n.left); q.push(n.right); } return out.join(','); }; const des=(s)=>{ const a=s.split(','); if(a[0]==='#') return null; const root={val:parseInt(a[0]),left:null,right:null}; const q=[root]; let i=1; while(q.length){ const n=q.shift(); const L=a[i++], R=a[i++]; if(L&&L!=='#'){ n.left={val:parseInt(L),left:null,right:null}; q.push(n.left);} if(R&&R!=='#'){ n.right={val:parseInt(R),left:null,right:null}; q.push(n.right);} } return root; }; return { serialize: ser, deserialize: des }; }` },
  },
  {
    id: "hard-009",
    slug: "hard-quickselect-kth",
    title: "Quickselect Kth Smallest",
    difficulty: "hard",
    tags: ["arrays", "divide-and-conquer"],
    statement: "Return the k-th smallest element using Quickselect.",
    starterCode: { javascript: jsStarter("Quickselect"), python: pyStarter("Quickselect"), cpp: cppStarter("Quickselect") },
    hints: ["Partition and recurse on relevant side."],
    solution: { javascript: `export function solve({nums,k}){ let l=0,r=nums.length-1,kIdx=k-1; const part=(l,r)=>{ const p=nums[r]; let i=l; for(let j=l;j<r;j++) if(nums[j]<=p) [nums[i++],nums[j]]=[nums[j],nums[i]]; [nums[i],nums[r]]=[nums[r],nums[i]]; return i; }; while(l<=r){ const m=part(l,r); if(m===kIdx) return nums[m]; if(m<kIdx) l=m+1; else r=m-1; } }` },
  },
  {
    id: "hard-010",
    slug: "hard-n-queens",
    title: "N Queens",
    difficulty: "hard",
    tags: ["backtracking"],
    statement: "Return all distinct solutions for placing n queens on an n×n board.",
    starterCode: { javascript: jsStarter("N Queens"), python: pyStarter("N Queens"), cpp: cppStarter("N Queens") },
    hints: ["Backtrack by row with column/diag constraints."],
    solution: { javascript: `export function solve(n){ const res=[], cols=new Set(), d1=new Set(), d2=new Set(), board=Array.from({length:n},()=>Array(n).fill('.')); const go=(r)=>{ if(r===n){ res.push(board.map(row=>row.join(''))); return;} for(let c=0;c<n;c++){ if(cols.has(c)||d1.has(r-c)||d2.has(r+c)) continue; cols.add(c); d1.add(r-c); d2.add(r+c); board[r][c]='Q'; go(r+1); board[r][c]='.'; cols.delete(c); d1.delete(r-c); d2.delete(r+c);} }; go(0); return res; }` },
  },
];

export const QUESTIONS: QuestionsIndex = {
  easy: EASY,
  intermediate: INTERMEDIATE,
  hard: HARD,
};


